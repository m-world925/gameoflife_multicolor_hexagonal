<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oscillators</title>
    <link rel="stylesheet" href="gameoflife.css">
</head>
<body>

    <header>Let's create oscillators!</header>

    <div class="container">

        <div class="counters">
            <h3 id="generation_count">Generation: 0</h3>
        </div>

        <canvas id="game_board"></canvas>

        <div class="controller">
            <div class="buttons">
                <button id="play_btn">Play</button>
                <button id="reset_btn">Reset</button>
            </div>
            <div class="speed_slider">
                <label for="trans_speed">Speed:</label>
                <input type="range" id="trans_speed" min="50" max="1000" step="50" value="500"><br>
                (faster-slower)
            </div>
        </div>
    </div>

    <footer>
        &copy; 2025 Mayu Watanabe
    </footer>

    <script>
        const canvas = document.getElementById("game_board");
        const ctx = canvas.getContext("2d");
        canvas.width = 500;
        canvas.height = 500;

        const hexRadius = 20;
        const colors = ["#FA8072", "#FFE4C4", "#7FFFD4", "#DDA0DD"];
        const rules = { B: [3], S: [2, 3], D: [0, 1, 4, 5, 6] };

        const rowHeight = hexRadius * 1.5;
        const colWidth = hexRadius * Math.sqrt(3);

        const rows = Math.floor(canvas.height / hexRadius);
        const cols = Math.floor(canvas.width / hexRadius);

        let grid = createHexGrid(rows, cols);

        function createHexGrid(rows, cols) {
            const grid = [];
            for (let i = 0; i < rows; i++) {
                const row = [];
                for (let j = 0; j < cols; j++) {
                    row.push({ alive: false, color: null });
                }
                grid.push(row);
            }
            return grid;
        }

        function drawHexGrid() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    const x = j * colWidth + (i % 2 == 1 ? colWidth / 2 : 0);
                    const y = i * rowHeight;
                    drawHexagon(x, y, hexRadius, grid[i][j]);
                }
            }
        }

        function drawHexagon(x, y, radius, cell) {
            ctx.beginPath();
            for (let i = 0; i < 6; i++) {
                const angle = Math.PI / 3 * i - Math.PI / 6;
                const xi = x + radius * Math.cos(angle);
                const yi = y + radius * Math.sin(angle);
                if (i === 0) ctx.moveTo(xi, yi);
                else ctx.lineTo(xi, yi);
            }
            ctx.closePath();
            ctx.fillStyle = cell.alive ? cell.color : "white";
            ctx.fill();
            ctx.strokeStyle = "black";
            ctx.stroke();
        }

        function getDominantColor(colorCount) {
            if (Object.keys(colorCount).length === 0) return null;
            const colorCalc = (hex) => {
                const r = parseInt(hex.substring(1, 3), 16);
                const g = parseInt(hex.substring(3, 5), 16);
                const b = parseInt(hex.substring(5, 7), 16);
                return r + g + b;
            };

            const maxCount = Math.max(...Object.values(colorCount));
            const candidates = Object.keys(colorCount).filter(color => colorCount[color] === maxCount);

            if (candidates.length === 1) return candidates[0];
            return candidates.sort((a, b) => colorCalc(a) - colorCalc(b))[0];
        }


        function countNeighbors(r, c) {
            const evenRow = [
                [-1, -1], [-1, 0],
                [0, -1], [0, 1],
                [1, -1], [1, 0],
                [-2, 0], [2, 0]
            ];
            const oddRow = [
                [-1, 0], [-1, 1],
                [0, -1], [0, 1],
                [1, 0], [1, 1],
                [-2, 0], [2, 0]
            ];

            const offsets = ( r % 2 == 0) ? evenRow : oddRow;
            let count = 0;
            const colorCount = {};

            offsets.forEach(([dr, dc]) => {
                const nr = r + dr;
                const nc = c + dc;
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                    const neighbor = grid[nr][nc];
                    if (neighbor.alive) {
                        count++;
                        colorCount[neighbor.color] = (colorCount[neighbor.color] || 0) + 1;
                    }
                }
            });

            const dominant = getDominantColor(colorCount);
            console.log(`Cell [${r},${c}] has ${count} alive neighbors.`);
            return { count, dominant };
        }

        function nextGeneration() {
            const newGrid = createHexGrid(rows, cols);
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const { count, dominant } = countNeighbors(r, c);
                    const cell = grid[r][c];
                    console.log(`Cell [${r},${c}] - Current: ${cell.alive ? cell.color : 'Dead'}, Dominant: ${dominant}`);
                    if (cell.alive) {
                        newGrid[r][c].alive = rules.S.includes(count);
                        newGrid[r][c].color = cell.color;
                    } else {
                        newGrid[r][c].alive = rules.B.includes(count);
                        newGrid[r][c].color = dominant || null;
                    }
                }
            }
            grid = newGrid;
            generationCount++;
            counters();
            drawHexGrid();
        }
        function getHexAtPosition(x, y) {
            let row = Math.floor(y / rowHeight);
            let col = Math.floor((x - (row % 2 === 1 ? colWidth / 2 : 0)) / colWidth);

            console.log(`Clicked at: (${x}, ${y})`);
            console.log(`Row: ${row}, Col: ${col}`);

            if (row >= 0 && row < rows && col >= 0 && col < cols) {
                return { row, col };
            }

            return null;
        }


        canvas.addEventListener("click", (event) => {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            const hex = getHexAtPosition(mouseX, mouseY);
            if (hex) {
                const cell = grid[hex.row][hex.col];
                cell.alive = !cell.alive;
                cell.color = cell.alive ? colors[Math.floor(Math.random() * colors.length)] : null;
                drawHexGrid();
            }
        });

        let generationCount = 0;
        function counters() {
            document.getElementById("generation_count").textContent = `Generation: ${generationCount}`;
        }


        function playGame() {
            const playButton = document.getElementById("play_btn");
            if (!window.transitionInterval) {
                startGame();
                playButton.textContent = "Pause";
            } else {
                stopGame();
                playButton.textContent = "Play";
            }
        }

        function startGame() {
            const transitionSpeed = document.getElementById("trans_speed").value;
            window.transitionInterval = setInterval(nextGeneration, transitionSpeed);
        }

        function stopGame() {
            clearInterval(window.transitionInterval);
            window.transitionInterval = null;
        }

        function init() {
            stopGame();
            generationCount = 1;
            grid = createHexGrid(rows, cols);
            counters();
            drawHexGrid();
            document.getElementById("play_btn").textContent = "Play";
        }

        init();

        document.getElementById("play_btn").addEventListener("click", playGame);
        document.getElementById("reset_btn").addEventListener("click", init);
        document.getElementById("trans_speed").addEventListener("input", function() {
            if (window.transitionInterval) {
                clearInterval(window.transitionInterval);
                startGame();
            }
        });
    </script>
</body>
</html>